Flyx 2.0 - Stream Beyond
← Back to AboutTechnical Documentation • Last Updated: December 2025
Reverse Engineering Streaming Providers
A comprehensive guide to bypassing embed protections and extracting clean m3u8 streams without ads, popups, or malware. Because you deserve to watch content without your browser catching fire.

⚠️
Educational Purpose Only
This documentation is provided for educational and research purposes. The techniques described here demonstrate how streaming site protections work and can be bypassed. Use this knowledge responsibly.

Contents
6%
01
Overview
02
Philosophy
03
DLHD Live TV
04
111movies (1movies)
05
VidSrc
06
Videasy
07
AnimeKai
08
Proxy Architecture
09
Common Techniques
10
Tools & Methods
11
Contributing
Overview
Most "free" streaming sites wrap their content in layers of obfuscation, aggressive advertising, and sometimes outright malware. But here's the thing: the actual video streams are just standard HLS (m3u8) files. All the garbage is just a wrapper designed to monetize you.

By reverse engineering these protections, we can extract the clean stream URLs and play them in our own player—no ads, no popups, no cryptocurrency miners running in the background.

✓ Working
DLHD Live TV
AES-128 HLS with session-based auth. Requires heartbeat to establish session before key fetch. Updated December 2025.

✓ Working
111movies
AES-256-CBC encryption with XOR obfuscation and alphabet substitution. Fully cracked December 2025.

✓ Working
VidSrc
Static decoders for HEX, ROT3, and Base64 formats. No remote script execution needed.

✓ Working
Videasy
17 servers across 8 languages. External decryption API for encrypted responses.

✓ Working
AnimeKai
Anime specialist with MegaUp CDN. Requires residential proxy to bypass datacenter IP blocking.

Philosophy
Why We Do This
The streaming sites we reverse engineer are not legitimate businesses. They profit from content they don't own by wrapping it in exploitative monetization. We're not stealing from creators—we're bypassing the middlemen who were already stealing.

"We are not pirates. We are pirates who rob pirates. It's like being a vigilante, except instead of fighting crime we are fighting pop-up advertisements and cryptocurrency miners."
The Rules
No Puppeteer/Browser Automation - Pure HTTP requests only. If we need a browser, we haven't cracked it properly.
No Embedding Their Players - Their players contain ads and tracking. We extract the stream and use our own player.
Document Everything - Knowledge should be shared so others can build on it.
Keep It Updated - Providers change their obfuscation. We adapt.
DLHD Live TV - Auth Token Discovery
Fully Reverse Engineered - December 2025
Overview
DLHD (daddyhd.com) provides live TV streams using HLS with AES-128 encryption. The key server initially appeared to block datacenter IPs, but reverse engineering their obfuscated JavaScript player revealed the real protection: Bearer token authentication.

The breakthrough came from analyzing the player iframe at epicplayplay.cfd, where we discovered that auth tokens are generated server-side and embedded in the page. With the correct token, key requests work from ANY IP—no residential proxy needed.

The Problem
Initial attempts to fetch encryption keys returned errors. The key server atchevy.kiko2.ru seemed to reject requests from datacenter IPs. We tried:

Different User-Agent strings
Various Referer headers
Cookie forwarding
TLS fingerprint spoofing
None worked. But the browser worked fine from the same IP. This meant it wasn't IP-based blocking—something else was happening.

The Discovery
By fetching and analyzing the player page at epicplayplay.cfd/premiumtv/daddyhd.php, we found the key: an AUTH_TOKEN variable embedded in the JavaScript.

Token Extraction
Copy
// Fetch the player page
const playerUrl = `https://epicplayplay.cfd/premiumtv/daddyhd.php?id=${channel}`;
const html = await fetch(playerUrl, {
  headers: {
    'User-Agent': 'Mozilla/5.0 ...',
    'Referer': 'https://daddyhd.com/',
  }
}).then(r => r.text());

// Extract the auth token
const match = html.match(/AUTH_TOKEN\s*=\s*["']([^"']+)["']/);
const authToken = match[1];
// Token looks like: "713384aaecd20309fbc8..."
The Algorithm (Updated December 2025)
DLHD added a heartbeat session requirement in December 2025. Simply having the auth token is no longer enough—you must establish a session via the heartbeat endpoint first.

1
Get Server Key
Call server_lookup?channel_id=premium{channel} to get CDN server (zeko, chevy, etc.)

2
Fetch Auth Token
Get AUTH_TOKEN and CHANNEL_KEY from player page

3
Establish Heartbeat Session
Call https://{server}.kiko2.ru/heartbeat with auth headers. Returns session expiry (~5 hours).

4
Fetch M3U8 Playlist
Build URL: https://{server}new.kiko2.ru/{server}/premium{channel}/mono.css

5
Fetch Key with Session
Request key with Authorization: Bearer {token} + X-Channel-Key headers

Heartbeat Session (New in Dec 2025)
Without calling the heartbeat endpoint first, key requests return error E2: "Session must be created via heartbeat first".

Heartbeat Request
// Establish session before fetching keys
const heartbeatUrl = 'https://chevy.kiko2.ru/heartbeat';
const response = await fetch(heartbeatUrl, {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${authToken}`,
    'X-Channel-Key': channelKey,  // e.g., "premium51"
    'Origin': 'https://epicplayplay.cfd',
    'Referer': 'https://epicplayplay.cfd/',
  }
});

// Response: {"expiry":1765944911,"message":"Session created","status":"ok"}
const { expiry, status } = await response.json();
// Session valid for ~5 hours (expiry is Unix timestamp)
Error Codes
E2
"Session must be created via heartbeat first"
Call heartbeat endpoint before fetching keys

E3
Token expired or invalid
Refresh auth token from player page

400
Missing X-Channel-Key header
Add X-Channel-Key header to heartbeat/key requests

Key Request Headers
The key server requires specific headers. The critical one is Authorization:

Required Headers for Key Fetch
{
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
  'Accept': '*/*',
  'Origin': 'https://epicplayplay.cfd',
  'Referer': 'https://epicplayplay.cfd/',
  'Authorization': 'Bearer ${authToken}',  // THE KEY!
  'X-Channel-Key': 'premium${channel}',
}
URL Patterns
GET
https://epicplayplay.cfd/premiumtv/daddyhd.php?id={channel}
Player page containing AUTH_TOKEN and CHANNEL_KEY

GET
https://{server}.kiko2.ru/heartbeat
Establish session. Requires: Authorization + X-Channel-Key headers

GET
https://chevy.giokko.ru/server_lookup?channel_id=premium{channel}
Returns JSON: {"server_key": "zeko"}

GET
https://{server}new.kiko2.ru/{server}/premium{channel}/mono.css
Returns HLS M3U8 playlist with AES-128 encryption

GET
https://{server}.kiko2.ru/key/premium{channel}/{keyId}
Returns 16-byte AES key (requires session + auth headers)

Implementation
Complete Session + Key Fetch
async function fetchDLHDKey(keyUrl, channel) {
  // Step 1: Get auth token from player page (cached)
  const { token, channelKey } = await getAuthToken(channel);
  if (!token) throw new Error('Failed to get auth token');
  
  // Step 2: Establish heartbeat session (required since Dec 2025)
  const hbResponse = await fetch('https://chevy.kiko2.ru/heartbeat', {
    headers: {
      'Authorization': `Bearer ${token}`,
      'X-Channel-Key': channelKey,
      'Origin': 'https://epicplayplay.cfd',
      'Referer': 'https://epicplayplay.cfd/',
    },
  });
  const { status, expiry } = await hbResponse.json();
  if (status !== 'ok') throw new Error('Heartbeat failed');
  
  // Step 3: Fetch key with session
  const response = await fetch(keyUrl, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'X-Channel-Key': channelKey,
      'Origin': 'https://epicplayplay.cfd',
      'Referer': 'https://epicplayplay.cfd/',
    },
  });
  
  const keyData = await response.arrayBuffer();
  if (keyData.byteLength !== 16) {
    const text = new TextDecoder().decode(keyData);
    if (text.includes('E2')) throw new Error('Session not established');
    throw new Error(`Invalid key: ${text}`);
  }
  
  return keyData; // Valid 16-byte AES key
}
Why This Works
The auth token + heartbeat session system is tied to the token, not the IP address. This means:

No residential proxy needed - Works from Cloudflare Workers
Session validity ~5 hours - Heartbeat returns Unix timestamp expiry
Auto-refresh sessions - We refresh 2 minutes before expiry
Per-channel isolation - Each channel needs its own session
No IP blocking - The "blocking" was just missing session
Session Management
For long viewing sessions, the session must be kept alive. Our implementation:

Caches sessions per channel with expiry tracking
Refreshes 2 minutes before expiry to avoid interruption
Retries with fresh session on E2 errors
Maximum cache TTL of 20 minutes regardless of expiry
Lessons Learned
"When requests fail from code but work in browser, don't assume IP blocking. Check what headers the browser is actually sending. The answer is usually in the JavaScript. And when that stops working, check if they added a session requirement."- Field Notes, December 2025
This crack evolved over time. First we discovered the Bearer token (worked for months), then DLHD added the heartbeat session requirement. The key insight: always monitor for new error codes and trace them back to the player JavaScript.

111movies (1movies) - Complete Breakdown
Fully Reverse Engineered - December 2025
Overview
111movies uses a Next.js frontend with a sophisticated encoding scheme to protect their API endpoints. The encoding involves AES-256-CBC encryption, XOR obfuscation, and custom alphabet substitution. We cracked it completely without any browser automation.

The Algorithm
1
Extract Page Data
Fetch the page and extract __NEXT_DATA__.props.pageProps.data

2
AES-256-CBC Encrypt
Encrypt the page data using static key and IV, output as hex string

3
XOR Obfuscation
XOR each character with a 9-byte rotating key

4
Base64 Encode
UTF-8 encode the XORed string, then Base64 with URL-safe characters

5
Alphabet Substitution
Replace each character using a shuffled alphabet mapping

Extracted Keys
These keys were extracted from their obfuscated JavaScript bundle (860-58807119fccb267b.js):

AES Key (32 bytes)
Copy
const AES_KEY = Buffer.from([
  3, 75, 207, 198, 39, 85, 65, 255,
  64, 89, 191, 251, 35, 214, 209, 210,
  62, 164, 155, 85, 247, 158, 167, 48,
  172, 84, 13, 18, 19, 166, 19, 57
]);
IV (16 bytes)
Copy
const AES_IV = Buffer.from([
  162, 231, 173, 134, 84, 100, 241, 33,
  5, 233, 223, 132, 245, 189, 171, 237
]);
XOR Key (9 bytes)
Copy
const XOR_KEY = Buffer.from([170, 162, 126, 126, 60, 255, 136, 130, 133]);
Alphabet Mapping
Copy
const STANDARD = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
const SHUFFLED = "TuzHOxl7b0RW9o_1FPV3eGfmL4Z5pD8cahBQr2U-6yvEYwngXCdJjANtqKIMiSks";
API Endpoints
GET
/{API_HASH}/{encoded}/sr
Returns list of available sources (Alpha, Charlie, Delta, etc.)

GET
/{API_HASH}/{source.data}
Returns JSON with m3u8 URL: {"url": "https://...m3u8", "tracks": [...]}

Required Headers
The API requires specific headers to return data instead of a 403:

Required Headers
{
  'X-Requested-With': 'XMLHttpRequest',  // Critical!
  'Content-Type': 'application/octet-stream',
  'Referer': 'https://111movies.com/',
  'User-Agent': 'Mozilla/5.0 ...'
}
CDN Proxy Requirement
The 1movies CDN (p.XXXXX.workers.dev) blocks datacenter IPs. Requests from Cloudflare Workers, AWS, Vercel, etc. return 403. Solution: route through a residential proxy (Raspberry Pi on home internet).

CDN Detection Pattern
// 1movies CDN URLs match this pattern:
// https://p.10014.workers.dev/...
function is1moviesCdnUrl(url) {
  if (url.includes('.workers.dev')) {
    if (url.match(/p\.\d+\.workers\.dev/)) return true;
  }
  return false;
}
How We Cracked It
Bundle Analysis: Downloaded their webpack chunks and searched for crypto-related strings
String Deobfuscation: Found the string array and decoder function, decoded all strings
Key Extraction: Located byte arrays being passed to createCipheriv
Algorithm Tracing: Followed the encoding flow from page data to API request
Header Discovery: Compared browser requests to our requests, found missing X-Requested-With
CDN Bypass: Discovered datacenter IP blocking, implemented residential proxy routing
VidSrc - Static Decoder Implementation
Working - Primary Provider
Overview
VidSrc (vidsrc-embed.ru → cloudnestra.com) is our primary provider for movies and TV shows. We reverse engineered their encoding schemes and implemented static decoders—no remote script execution required. This avoids Cloudflare detection from fetching decoder scripts.

Architecture
Request Flow
1. vidsrc-embed.ru/embed/{type}/{tmdbId}
   └─> Extract RCP iframe URL

2. cloudnestra.com/rcp/{hash}
   └─> Extract prorcp/srcrcp URL (may have Turnstile)

3. cloudnestra.com/prorcp/{hash}
   └─> Extract encoded div content

4. Static decode → HLS stream URL
Encoding Formats Detected
VidSrc uses multiple encoding formats. Our static decoders handle all of them:

HEX Format (Primary - December 2025)
// Algorithm: Reverse → Subtract 1 from each char → Hex decode
function decodeHexFormat(encoded) {
  // Step 1: Reverse the string
  const reversed = encoded.split('').reverse().join('');
  
  // Step 2: Subtract 1 from each character code
  let adjusted = '';
  for (let i = 0; i < reversed.length; i++) {
    adjusted += String.fromCharCode(reversed.charCodeAt(i) - 1);
  }
  
  // Step 3: Remove non-hex characters (like colons)
  const hexClean = adjusted.replace(/[^0-9a-fA-F]/g, '');
  
  // Step 4: Convert hex pairs to ASCII
  let decoded = '';
  for (let i = 0; i < hexClean.length; i += 2) {
    decoded += String.fromCharCode(parseInt(hexClean.substr(i, 2), 16));
  }
  return decoded;
}
ROT3 Format
// Content starts with "eqqmp://" (https with -3 shift)
// Shift letters FORWARD by 3 to decode
function decodeRot3(encoded) {
  let decoded = '';
  for (const char of encoded) {
    const code = char.charCodeAt(0);
    if (code >= 97 && code <= 122) { // lowercase
      decoded += String.fromCharCode(((code - 97 + 3) % 26) + 97);
    } else if (code >= 65 && code <= 90) { // uppercase
      decoded += String.fromCharCode(((code - 65 + 3) % 26) + 65);
    } else {
      decoded += char; // Numbers NOT shifted!
    }
  }
  return decoded;
}
Reversed Base64 Format
// Content starts with "==" (reversed padding)
// Algorithm: Reverse → Base64 decode → Subtract shift
function decodeBase64Format(encoded, shift = 3) {
  let data = encoded.startsWith('=') ? encoded.substring(1) : encoded;
  data = data.split('').reverse().join('');
  data = data.replace(/-/g, '+').replace(/_/g, '/');
  while (data.length % 4 !== 0) data += '=';
  
  const decoded = atob(data);
  let result = '';
  for (let i = 0; i < decoded.length; i++) {
    result += String.fromCharCode(decoded.charCodeAt(i) - shift);
  }
  return result;
}
PlayerJS Format (Custom Base64)
// Uses shuffled base64 alphabet
const CUSTOM_ALPHABET = 'ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz0123456789+/=';

// #0 prefix: Direct custom base64 decode
// #1 prefix: Replace # with + first, then decode
Cloudflare Turnstile Bypass
Some requests trigger Cloudflare Turnstile. We support automatic solving via CapSolver API (optional, ~$2-3 per 1000 solves). Set CAPSOLVER_API_KEY environment variable.

Security Note
VidSrc is disabled by default because the fallback dynamic decoder usesnew Function() to execute remote scripts. Enable with ENABLE_VIDSRC_PROVIDER=trueonly if you accept this risk. Our static decoders avoid this for known formats.

Videasy - Multi-Language Extraction
Working - 17 Servers, 8 Languages
Overview
Videasy provides excellent multi-language support with 17 servers across 8 languages. Their API returns encrypted responses that we decrypt using an external service.

Available Servers
Server Configuration
// English Servers (Priority 1-8)
Neon      → myflixerzupcloud  (English)
Sage      → 1movies           (English)
Cypher    → moviebox          (English)
Yoru      → cdn               (English, MOVIE ONLY)
Reyna     → primewire         (English)
Omen      → onionplay         (English)
Breach    → m4uhd             (English)
Vyse      → hdmovie           (English)

// International Servers
Killjoy   → meine?language=german   (German)
Harbor    → meine?language=italian  (Italian)
Chamber   → meine?language=french   (French, MOVIE ONLY)
Gekko     → cuevana-latino          (Latin Spanish)
Kayo      → cuevana-spanish         (Spanish)
Raze      → superflix              (Portuguese)
Phoenix   → overflix               (Portuguese)
Astra     → visioncine             (Portuguese)
API Flow
Extraction Process
// 1. Build API URL
const url = `https://api.videasy.net/{endpoint}/sources-with-title
  ?title={title}&mediaType={type}&year={year}&tmdbId={tmdbId}
  &seasonId={season}&episodeId={episode}`;

// 2. Fetch encrypted response
const encrypted = await fetch(url).then(r => r.text());

// 3. Decrypt via external API
const decrypted = await fetch('https://enc-dec.app/api/dec-videasy', {
  method: 'POST',
  body: JSON.stringify({ text: encrypted, id: tmdbId })
}).then(r => r.json());

// 4. Extract stream URL
const streamUrl = decrypted.result.sources[0].url;
Episode Number Handling
Some shows (like One Piece) use absolute episode numbers on TMDB. Videasy expects relative episode numbers within each season. We detect this and convert automatically:

Episode Conversion
// TMDB: Season 2, Episode 62 (absolute)
// Videasy expects: Season 2, Episode 1 (relative)

const firstEpisodeOfSeason = await getSeasonFirstEpisode(tmdbId, season);
if (firstEpisodeOfSeason > 1) {
  relativeEpisode = episode - firstEpisodeOfSeason + 1;
}
Rate Limiting
Videasy enforces rate limits. We implement exponential backoff with configurable delays:

Minimum delay: 800ms between requests
Maximum delay: 2000ms (with backoff)
Backoff multiplier: 1.5x per consecutive failure
Automatic retry on HTTP 429 with Retry-After header support
AnimeKai - Anime Specialist
Working - Sub/Dub Support
Overview
AnimeKai is our dedicated anime provider, offering both subbed and dubbed versions with proper episode mapping. The main challenges are ID mapping (TMDB → MAL/AniList) and their MegaUp CDN which blocks datacenter IPs.

Complex Extraction Flow
1
ID Mapping
Convert TMDB ID → MAL/AniList ID using ARM mapping API

2
Search AnimeKai
Search database for anime, get content_id (kai_id)

3
Get Episodes
Encrypt content_id → fetch episodes list → parse HTML

4
Get Servers
Encrypt episode token → fetch servers (sub/dub) → parse HTML

5
Get Embed
Encrypt server lid → fetch encrypted embed URL

6
Decrypt Stream
Decrypt MegaUp embed → extract HLS stream URL

Encryption/Decryption
AnimeKai uses custom encryption for all API parameters. We use the enc-dec.app service for encryption and decryption:

Encryption API
// Encrypt for AnimeKai
const encrypted = await fetch(
  `https://enc-dec.app/api/enc-kai?text=${encodeURIComponent(text)}`
).then(r => r.json());

// Decrypt from AnimeKai
const decrypted = await fetch('https://enc-dec.app/api/dec-kai', {
  method: 'POST',
  body: JSON.stringify({ text: encryptedText })
}).then(r => r.json());
MegaUp CDN Decryption
MegaUp embeds (/e/{videoId}) need special handling. The video data is encrypted and requires the dec-mega API:

MegaUp Decryption Flow
// 1. Extract video ID from embed URL
const [, baseUrl, videoId] = embedUrl.match(/^(https?:\/\/[^/]+)\/e\/([^/?#]+)/);

// 2. Fetch encrypted media data (via residential proxy!)
const mediaData = await fetch(`${baseUrl}/media/${videoId}`);

// 3. Decrypt with enc-dec.app
// CRITICAL: User-Agent must match what RPI proxy used!
const decrypted = await fetch('https://enc-dec.app/api/dec-mega', {
  method: 'POST',
  body: JSON.stringify({ 
    text: mediaData.result,
    agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)...'
  })
});

// 4. Extract stream URL from decrypted response
const streamUrl = decrypted.result.sources[0].file;
Season/Episode Mapping Challenges
Anime naming is complex. TMDB's "Bleach Season 2" is "Bleach: Thousand-Year Blood War" on AnimeKai. We handle this with multiple search strategies:

MAL ID lookup: Most reliable when available
Season name search: Use TMDB season name (e.g., "Thousand-Year Blood War")
Title variants: Try "Title II", "Title Season 2", "Title 2nd Season", etc.
Scoring algorithm: Rank results by title similarity, penalize "Movie", "OVA", etc.
CDN Blocking
MegaUp CDN blocks ALL datacenter IPs and requests with Origin headers. This affects:

Cloudflare Workers
AWS Lambda/EC2
Vercel Edge Functions
Any VPS or cloud provider
Browser XHR (adds Origin header automatically)
Solution: Route through Raspberry Pi on residential internet. See Proxy Architecture section.

Proxy Architecture
Production Ready
The Problem
Multiple CDNs (MegaUp for AnimeKai, p.XXXXX.workers.dev for 1movies) block datacenter IPs. They also reject requests with Origin headers (which browsers add automatically to XHR).

The Solution: Multi-Layer Proxy
Request Flow
Browser (XHR with Origin header)
    ↓
Vercel API Route (datacenter IP)
    ↓
Cloudflare Worker /animekai route (datacenter IP)
    ↓
Raspberry Pi Proxy (RESIDENTIAL IP, no Origin header)
    ↓
CDN (accepts residential IP without Origin)
    ↓
HLS Stream ← flows back through the chain
Cloudflare Worker Routes
Route Configuration
/stream   → Standard proxy with Referer header
            Used for: Videasy, VidSrc, most CDNs

/animekai → Forwards to RPI residential proxy
            Used for: AnimeKai (MegaUp), 1movies CDN
            Strips Origin header, uses residential IP
CDN Detection
proxy-config.ts
// MegaUp CDN (AnimeKai)
function isMegaUpCdnUrl(url) {
  return url.includes('megaup') || 
         url.includes('hub26link') || 
         url.includes('app28base') ||
         url.includes('code29wave') ||
         url.includes('pro25zone');
}

// 1movies CDN
function is1moviesCdnUrl(url) {
  if (url.includes('.workers.dev')) {
    if (url.match(/p\.\d+\.workers\.dev/)) return true;
  }
  return false;
}

// Route decision in maybeProxyUrl()
if (isAnimeKai || isMegaUpCdn || is1moviesCdn) {
  return getAnimeKaiProxyUrl(url); // → /animekai → RPI
} else {
  return getStreamProxyUrl(url);   // → /stream → direct
}
RPI Proxy Server
The Raspberry Pi runs a simple Node.js server exposed via Cloudflare Tunnel. Key features:

No Origin/Referer headers: CDNs that block these get clean requests
Residential IP: Home internet connection passes IP checks
Response caching: Short TTL for m3u8, longer for segments
Rate limiting: Prevents abuse
API key auth: Only our Cloudflare Worker can use it
User-Agent Consistency
Critical: The User-Agent header must be identical across the entire chain. MegaUp's decryption is tied to the User-Agent that fetched the encrypted data. If the RPI proxy uses a different User-Agent than what we send to enc-dec.app, decryption fails.

User-Agent Propagation
// Pass User-Agent to RPI proxy
const proxyUrl = `${baseUrl}/animekai?url=${encodeURIComponent(targetUrl)}&ua=${encodeURIComponent(userAgent)}`;

// RPI proxy uses the same User-Agent for fetch
const options = {
  headers: {
    'User-Agent': customUserAgent || defaultUserAgent,
    // NO Origin or Referer headers!
  }
};
Common Obfuscation Techniques
String Array Obfuscation
Most providers store strings in an array and access them via index. The array is often rotated or encoded.

Before Deobfuscation
const _0x1234 = ['aGVsbG8=', 'd29ybGQ='];
const a = atob(_0x1234[0]); // "hello"
const b = atob(_0x1234[1]); // "world"
Control Flow Flattening
Code is restructured into a switch statement inside a while loop, making it hard to follow the execution flow.

Flattened Control Flow
let state = 0;
while (true) {
  switch (state) {
    case 0: doA(); state = 3; break;
    case 1: return result;
    case 2: doC(); state = 1; break;
    case 3: doB(); state = 2; break;
  }
}
Dead Code Injection
Meaningless code is added to confuse analysis. Look for code that never executes or variables that are never used.

Proxy Functions
Simple operations are wrapped in functions to hide their purpose:

Proxy Function Example
// Instead of: a + b
function _0xabc(x, y) { return x + y; }
const result = _0xabc(a, b);
Packed JavaScript (p,a,c,k,e,d)
Common in embed pages. The code is compressed using a custom base encoding:

Unpacking PACKED JS
// Packed format:
eval(function(p,a,c,k,e,d){...}('encoded',base,count,'keywords'.split('|')))

// Unpacking algorithm:
// 1. Extract: encoded string, base, count, keywords array
// 2. For each keyword index (count-1 to 0):
//    - Convert index to base-N string (unbaser)
//    - Replace all occurrences in encoded string
// 3. Result is the original JavaScript
XOR Encryption
Simple but effective. Each character is XORed with a key byte:

XOR Pattern
// Encryption/Decryption (same operation)
function xor(text, key) {
  let result = '';
  for (let i = 0; i < text.length; i++) {
    result += String.fromCharCode(
      text.charCodeAt(i) ^ key[i % key.length]
    );
  }
  return result;
}
Custom Base64 Alphabets
Standard Base64 uses A-Za-z0-9+/. Providers often shuffle this alphabet to break standard decoders:

Custom Alphabet Detection
// Standard: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
// PlayerJS: ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz0123456789+/
//           (first 26 chars swapped with next 26)

// Detection: Look for base64-like strings that don't decode properly
// Solution: Find the alphabet in their decoder function
Tools & Methods
Essential Tools
Browser DevTools
Network tab for request analysis, Sources for debugging, Console for testing. Set breakpoints on XHR/fetch.

de4js
Online JavaScript deobfuscator. Good starting point for most obfuscation. Handles string array rotation.

AST Explorer
Visualize JavaScript AST. Essential for understanding code structure and writing transforms.

CyberChef
Swiss army knife for encoding/decoding. Base64, XOR, AES, hex, everything. Chain operations together.

Burp Suite / mitmproxy
Intercept and modify HTTP traffic. See exactly what the browser sends and receives.

Node.js REPL
Quick testing of decoding functions. Copy their code, run it locally, compare outputs.

Methodology
Capture Traffic: Use DevTools Network tab to see all requests. Filter by XHR/Fetch.
Identify API Calls: Find requests that return stream data or encrypted blobs.
Trace Parameters: Work backwards from API call to find how params are generated.
Extract Keys: Search for crypto functions (createCipheriv, CryptoJS), find their inputs.
Replicate: Build your own implementation, compare outputs byte-by-byte.
Test Headers: If requests fail, compare headers with browser requests. X-Requested-With is often required.
Check IP/Origin: If still failing, the CDN might block datacenter IPs or Origin headers.
Common Pitfalls
Missing Headers: APIs often require X-Requested-With: XMLHttpRequest
Timing Issues: Some tokens are time-based, ensure your clock is synced
Session State: Some sites require cookies from initial page load
IP Restrictions: CDNs may block datacenter IPs, need residential proxy
Origin Header: Browser XHR adds Origin automatically, some CDNs reject it
User-Agent Mismatch: Decryption may be tied to the User-Agent that fetched the data
Rate Limiting: Implement exponential backoff, respect Retry-After headers
Debugging Tips
Useful DevTools Snippets
// Break on all XHR/fetch requests
const origFetch = window.fetch;
window.fetch = function(...args) {
  debugger;
  return origFetch.apply(this, args);
};

// Log all postMessage events (iframe communication)
window.addEventListener('message', e => console.log('postMessage:', e.data));

// Find where a string is constructed
// Set conditional breakpoint: result.includes('m3u8')
Contributing
Found a new provider? Cracked an obfuscation we haven't documented? We'd love to hear about it.

What We're Looking For
New provider extraction methods
Updates when providers change their obfuscation
Better/cleaner implementations of existing extractors
Documentation improvements
CDN bypass techniques
Guidelines
No Puppeteer/browser automation - pure HTTP only
Document your methodology, not just the code
Include the keys/constants you extracted
Test with multiple content IDs to ensure reliability
Note any rate limits or IP restrictions
This documentation is part of the Flyx project. Check out the full About page for the complete story of how we built an ethical streaming platform by reverse engineering the unethical ones.
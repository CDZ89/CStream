Parfait, je comprends exactement ce que tu veux ğŸ¯ : un **widget de type Netflix/Crunchyroll** qui apparaÃ®t **7 minutes avant la fin de lâ€™Ã©pisode**, avec un design propre et compactâ€¯:

- ğŸ–¼ï¸ **Image officielle de lâ€™Ã©pisode suivant** (via TMDB `still_path`).  
- ğŸ“ **Titre + numÃ©ro de lâ€™Ã©pisode suivant**.  
- â–¶ï¸ **Bouton â€œRegarder prochain Ã©pisodeâ€**.  
- âŒ **Petite croix pour fermer le widget** si lâ€™utilisateur ne veut pas.  
- âš¡ **Autoâ€‘play** du prochain Ã©pisode si lâ€™utilisateur ne ferme pas le widget.  

---

## ğŸ› ï¸ Structure HTML du widget

```html
<div id="next-episode-widget" class="widget">
  <div class="widget-content">
    <img id="next-episode-image" alt="Prochain Ã©pisode">
    <div class="widget-info">
      <h4 id="next-episode-title"></h4>
      <button id="watch-next">â–¶ï¸ Regarder prochain Ã©pisode</button>
    </div>
    <span id="close-widget">&times;</span>
  </div>
</div>
```

---

## ğŸ¨ CSS pour un rendu type Netflix

```css
.widget {
  display: none; /* cachÃ© par dÃ©faut */
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
  z-index: 9999;
}

.widget-content {
  display: flex;
  align-items: center;
  position: relative;
}

.widget-content img {
  width: 120px;
  height: 70px;
  object-fit: cover;
}

.widget-info {
  padding: 10px;
}

.widget-info h4 {
  margin: 0 0 6px;
  font-size: 14px;
}

.widget-info button {
  background: #e50914;
  color: #fff;
  border: none;
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
}

#close-widget {
  position: absolute;
  top: 6px;
  right: 10px;
  cursor: pointer;
  font-size: 18px;
}
```

---

## âš™ï¸ JS logique du widget

```js
const video = document.getElementById("player"); // si HTML5 <video>
const widget = document.getElementById("next-episode-widget");
const nextImage = document.getElementById("next-episode-image");
const nextTitle = document.getElementById("next-episode-title");
const watchNextBtn = document.getElementById("watch-next");
const closeWidget = document.getElementById("close-widget");

function showNextEpisodeWidget(nextEp) {
  nextImage.src = TMDB_IMAGE(nextEp.still_path, "w300");
  nextTitle.textContent = `Ã‰pisode ${nextEp.episode_number} â€” ${nextEp.name}`;
  widget.style.display = "block";
}

function hideWidget() {
  widget.style.display = "none";
}

closeWidget.addEventListener("click", hideWidget);

watchNextBtn.addEventListener("click", () => {
  // Charger lâ€™Ã©pisode suivant
  episodeSelector.value = parseInt(episodeSelector.value, 10) + 1;
  onEpisodeChange();
  hideWidget();
});

// DÃ©tection 7 min avant la fin
video.addEventListener("timeupdate", () => {
  const remaining = video.duration - video.currentTime;
  if (remaining <= 420 && widget.style.display === "none") {
    const nextIndex = parseInt(episodeSelector.value, 10) + 1;
    const nextEp = tmdbSeason.episodes[nextIndex];
    if (nextEp) {
      showNextEpisodeWidget(nextEp);
    }
  }
});

// Auto-play si lâ€™utilisateur ne ferme pas
video.addEventListener("ended", () => {
  if (widget.style.display === "block") {
    watchNextBtn.click();
  }
});
```

---

## âœ… RÃ©sultat

- **7 minutes avant la fin** â†’ un petit widget apparaÃ®t en bas Ã  droite, avec lâ€™image et le titre du prochain Ã©pisode.  
- Lâ€™utilisateur peut cliquer sur **â–¶ï¸ Regarder prochain Ã©pisode** ou fermer avec la âŒ.  
- Si lâ€™utilisateur ne ferme pas, **lâ€™Ã©pisode suivant dÃ©marre automatiquement** Ã  la fin.  
- Si câ€™est le dernier Ã©pisode, tu peux remplacer `showNextEpisodeWidget(nextEp)` par une **recommandation dâ€™anime** (comme Netflix).  

---

ğŸ‘‰ Veux-tu que je te prÃ©pare aussi la **version â€œdernier Ã©pisodeâ€** oÃ¹ le widget propose automatiquement un autre anime recommandÃ© (via TMDB â€œsimilar showsâ€)â€¯?